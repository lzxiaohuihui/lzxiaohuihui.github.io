<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Kafka | 北冥无鱼</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="/img/tiger.png">
    <meta name="description" content="一个基于VuePress的 知识管理&amp;博客 主题">
    <meta name="keywords" content="vuepress,theme,blog,vdoing">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/assets/css/0.styles.95c3837a.css" as="style"><link rel="preload" href="/assets/js/app.346e1551.js" as="script"><link rel="preload" href="/assets/js/2.2bb1a3f0.js" as="script"><link rel="preload" href="/assets/js/14.1e95b815.js" as="script"><link rel="prefetch" href="/assets/js/10.941f9595.js"><link rel="prefetch" href="/assets/js/11.b7d791b9.js"><link rel="prefetch" href="/assets/js/12.ebbfbefa.js"><link rel="prefetch" href="/assets/js/13.55bee0ae.js"><link rel="prefetch" href="/assets/js/15.2d2eef87.js"><link rel="prefetch" href="/assets/js/16.39294289.js"><link rel="prefetch" href="/assets/js/17.743ca12b.js"><link rel="prefetch" href="/assets/js/18.50024288.js"><link rel="prefetch" href="/assets/js/19.cfa6e429.js"><link rel="prefetch" href="/assets/js/20.da3fce67.js"><link rel="prefetch" href="/assets/js/21.419116e7.js"><link rel="prefetch" href="/assets/js/22.6d444788.js"><link rel="prefetch" href="/assets/js/23.c331d239.js"><link rel="prefetch" href="/assets/js/24.f09ffbc2.js"><link rel="prefetch" href="/assets/js/25.954abaad.js"><link rel="prefetch" href="/assets/js/26.4a4aff6b.js"><link rel="prefetch" href="/assets/js/27.1aaac913.js"><link rel="prefetch" href="/assets/js/28.4cd79971.js"><link rel="prefetch" href="/assets/js/29.40208485.js"><link rel="prefetch" href="/assets/js/3.9cf196df.js"><link rel="prefetch" href="/assets/js/30.f3086bc0.js"><link rel="prefetch" href="/assets/js/31.8acc6cef.js"><link rel="prefetch" href="/assets/js/32.e9cde725.js"><link rel="prefetch" href="/assets/js/33.1ee5100f.js"><link rel="prefetch" href="/assets/js/34.e22db86e.js"><link rel="prefetch" href="/assets/js/35.4eafac50.js"><link rel="prefetch" href="/assets/js/36.1c1ee1f4.js"><link rel="prefetch" href="/assets/js/37.677fb893.js"><link rel="prefetch" href="/assets/js/38.9cd6536e.js"><link rel="prefetch" href="/assets/js/39.733cb66f.js"><link rel="prefetch" href="/assets/js/4.5d4b1e3e.js"><link rel="prefetch" href="/assets/js/40.c37b65b2.js"><link rel="prefetch" href="/assets/js/41.1f7a5823.js"><link rel="prefetch" href="/assets/js/42.d5d8d61c.js"><link rel="prefetch" href="/assets/js/43.0440be56.js"><link rel="prefetch" href="/assets/js/44.46973971.js"><link rel="prefetch" href="/assets/js/45.30b89f29.js"><link rel="prefetch" href="/assets/js/46.84eaf89e.js"><link rel="prefetch" href="/assets/js/47.0a145016.js"><link rel="prefetch" href="/assets/js/48.8c43259c.js"><link rel="prefetch" href="/assets/js/49.fa78dd64.js"><link rel="prefetch" href="/assets/js/5.7b963edb.js"><link rel="prefetch" href="/assets/js/50.84e3f3a9.js"><link rel="prefetch" href="/assets/js/51.477ee945.js"><link rel="prefetch" href="/assets/js/52.f118ef1f.js"><link rel="prefetch" href="/assets/js/53.a43cea39.js"><link rel="prefetch" href="/assets/js/54.24040505.js"><link rel="prefetch" href="/assets/js/55.48b7784e.js"><link rel="prefetch" href="/assets/js/56.d6fc5474.js"><link rel="prefetch" href="/assets/js/57.2be4b3b9.js"><link rel="prefetch" href="/assets/js/58.12e8eb95.js"><link rel="prefetch" href="/assets/js/59.11d2261d.js"><link rel="prefetch" href="/assets/js/6.cd22f69f.js"><link rel="prefetch" href="/assets/js/60.3ff6cfa9.js"><link rel="prefetch" href="/assets/js/61.21178592.js"><link rel="prefetch" href="/assets/js/62.1352608c.js"><link rel="prefetch" href="/assets/js/63.050641e9.js"><link rel="prefetch" href="/assets/js/64.d6d2d9e3.js"><link rel="prefetch" href="/assets/js/65.434963df.js"><link rel="prefetch" href="/assets/js/66.d0d97246.js"><link rel="prefetch" href="/assets/js/67.e329127c.js"><link rel="prefetch" href="/assets/js/68.7188bc65.js"><link rel="prefetch" href="/assets/js/69.868797a3.js"><link rel="prefetch" href="/assets/js/7.56bd88c1.js"><link rel="prefetch" href="/assets/js/70.fe5b1b21.js"><link rel="prefetch" href="/assets/js/71.f427eba0.js"><link rel="prefetch" href="/assets/js/72.8f3d4a59.js"><link rel="prefetch" href="/assets/js/73.a3c0ad82.js"><link rel="prefetch" href="/assets/js/74.4411d6f8.js"><link rel="prefetch" href="/assets/js/75.22170cc4.js"><link rel="prefetch" href="/assets/js/76.beca6f44.js"><link rel="prefetch" href="/assets/js/77.04a63c9c.js"><link rel="prefetch" href="/assets/js/78.a6f5f2b5.js"><link rel="prefetch" href="/assets/js/79.419b9cef.js"><link rel="prefetch" href="/assets/js/8.682d07e5.js"><link rel="prefetch" href="/assets/js/80.fea58868.js"><link rel="prefetch" href="/assets/js/81.5621bd89.js"><link rel="prefetch" href="/assets/js/82.64069ab7.js"><link rel="prefetch" href="/assets/js/83.37c14276.js"><link rel="prefetch" href="/assets/js/84.ae6c6209.js"><link rel="prefetch" href="/assets/js/85.b89b8c71.js"><link rel="prefetch" href="/assets/js/86.edc5934a.js"><link rel="prefetch" href="/assets/js/87.f9e215fa.js"><link rel="prefetch" href="/assets/js/88.40c5928c.js"><link rel="prefetch" href="/assets/js/89.be2ef4b1.js"><link rel="prefetch" href="/assets/js/9.f02c9057.js"><link rel="prefetch" href="/assets/js/90.8c27d903.js"><link rel="prefetch" href="/assets/js/91.1ede16f3.js"><link rel="prefetch" href="/assets/js/92.118ff1df.js"><link rel="prefetch" href="/assets/js/93.9773dab5.js"><link rel="prefetch" href="/assets/js/94.400d48d0.js"><link rel="prefetch" href="/assets/js/95.a2f813ab.js"><link rel="prefetch" href="/assets/js/96.ac3ab234.js">
    <link rel="stylesheet" href="/assets/css/0.styles.95c3837a.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/tiger.png" alt="北冥无鱼" class="logo"> <span class="site-name can-hide">北冥无鱼</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/e0425d/" class="nav-link">Java</a></div><div class="nav-item"><a href="/pages/7387ee/" class="nav-link">科研</a></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">生活</a></div><div class="nav-item"><a href="/pages/4df89e/" class="nav-link">C++</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/e0425d/" class="nav-link">Java</a></div><div class="nav-item"><a href="/pages/7387ee/" class="nav-link">科研</a></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">生活</a></div><div class="nav-item"><a href="/pages/4df89e/" class="nav-link">C++</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>中间件</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9749fb/" class="sidebar-link">消息队列</a></li><li><a href="/pages/467ce0/" class="sidebar-link">ZooKeeper</a></li><li><a href="/pages/11f4c8/" aria-current="page" class="active sidebar-link">Kafka</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/11f4c8/#阻塞队列" class="sidebar-link">阻塞队列</a></li><li class="sidebar-sub-header level2"><a href="/pages/11f4c8/#kafka入门" class="sidebar-link">Kafka入门</a></li><li class="sidebar-sub-header level2"><a href="/pages/11f4c8/#kafka为什么这么快" class="sidebar-link">Kafka为什么这么快</a></li><li class="sidebar-sub-header level2"><a href="/pages/11f4c8/#夺命连环问" class="sidebar-link">夺命连环问</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#说说你对kafka的理解" class="sidebar-link">说说你对Kafka的理解</a></li><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#消息队列模型知道吗-kafka是怎么做到支持这两种模型的" class="sidebar-link">消息队列模型知道吗？kafka是怎么做到支持这两种模型的？</a></li><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#能说说kafka通信过程原理吗" class="sidebar-link">能说说kafka通信过程原理吗？</a></li><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#发送消息时如何选择分区的" class="sidebar-link">发送消息时如何选择分区的？</a></li><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#为什么需要分区-有什么好处" class="sidebar-link">为什么需要分区？有什么好处？</a></li><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#详细说说消费者组和消费者重平衡" class="sidebar-link">详细说说消费者组和消费者重平衡？</a></li><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#分区分配策略" class="sidebar-link">分区分配策略？</a></li><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#消息传递语义剖析" class="sidebar-link">消息传递语义剖析</a></li><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#kafka三次消息传递" class="sidebar-link">Kafka三次消息传递</a></li><li class="sidebar-sub-header level3"><a href="/pages/11f4c8/#消息丢失场景" class="sidebar-link">消息丢失场景</a></li><li class="sidebar-sub-header level4"><a href="/pages/11f4c8/#producer端" class="sidebar-link">Producer端</a></li><li class="sidebar-sub-header level4"><a href="/pages/11f4c8/#broker端" class="sidebar-link">Broker端</a></li><li class="sidebar-sub-header level4"><a href="/pages/11f4c8/#consumer端" class="sidebar-link">Consumer端</a></li><li class="sidebar-sub-header level4"><a href="/pages/11f4c8/#解决方案" class="sidebar-link">解决方案</a></li></ul></li></ul></li><li><a href="/pages/2ca146/" class="sidebar-link">RabbitMQ</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目记录</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>秋招</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Java</span></li><li data-v-06225672><span data-v-06225672>中间件</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/lzxiaohuihui" target="_blank" title="作者" class="beLink" data-v-06225672>Wenli</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-02-24</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">Kafka<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="阻塞队列"><a href="#阻塞队列" class="header-anchor">#</a> 阻塞队列</h2> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230224151245096.png" alt="image-20230224151245096"></p> <p><strong>BlockingQueue</strong></p> <ul><li>解决线程通信的问题</li> <li>阻塞方法：put、take</li></ul> <p><strong>生产者消费者模式</strong></p> <ul><li>生产者：产生数据的线程</li> <li>消费者：使用数据的线程</li></ul> <p><strong>实现类</strong></p> <ul><li>ArrayBlockingQueue</li> <li>LinkedBlockQueue</li> <li>PriorityBlockingQueue，SynchronousQueue，DelayQueue等</li></ul> <p><strong>示例</strong></p> <ul><li>生产者线程</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;生产:&quot;</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><ul><li>消费者线程</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;消费:&quot;</span> <span class="token operator">+</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>结果</strong></p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230224152954733.png" alt="image-20230224152954733"></p> <h2 id="kafka入门"><a href="#kafka入门" class="header-anchor">#</a> Kafka入门</h2> <ul><li>Kafka是一个分布式的流媒体平台；</li> <li>应用：<strong>消息系统</strong>、日志收集、用户行为追踪、流失处理。</li></ul> <p>Kafka是一个消息队列，放里面放数据叫生产者，取数据叫消费者。</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227103114319.png" alt="image-20230227103114319"></p> <p>一个消息中间件，队列不单单只有一个，然后给每个队列取个名字，叫topic。</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227103159778.png" alt="image-20230227103159778"></p> <p>然后生产者，消费者就到指定的消息队列中存取数据就可以了。</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227103243177.png" alt="image-20230227103243177"></p> <p>为了提高一个队列的吞吐量，Kafka会把topic分区</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227103347739.png" alt="image-20230227103347739"></p> <p>实际上，生产者消费者是到指定topic，指定分区中存取数据</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227103438959.png" alt="image-20230227103438959"></p> <p>一台Kafka服务器叫做Broker</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227103516668.png" alt="image-20230227103516668"></p> <p>一个话题中的多个分区，可能存在不同的服务器上</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227104352461.png" alt="image-20230227104352461"></p> <p>Kafka将数据存放在不同的分区上，同时也会将分区备份，存在不同的broker上。备份分区只用做备份，不做读写。当某个broker挂了，那么就从其它broker中的分区作为主分区。</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227104842361.png" alt="image-20230227104842361"></p> <p>消费者</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227110518895.png" alt="image-20230227110518895"></p> <p>消费者可以有多个，形成一个消费者组。比如本来一个消费者要消费三个分区，那么可以通过一个消费者组，让三个消费者分别消费一个分区。</p> <ul><li><p>使用消息队列不可能是单机的（必然是分布式or集群）</p></li> <li><p>Kafka会将partition以消息日志的方式(落磁盘)存储起来，通过 顺序访问IO和缓存(等到一定的量或时间)才真正把数据写到磁盘上，来提高速度。</p></li> <li><p>Kafka会将数据写到partition，单个partition的写入是有顺序的。如果要保证全局有序，那只能写入一个partition中。如果要消费也有序，消费者也只能有一个。</p></li> <li><p>凡是分布式就无法避免网络抖动/机器宕机等问题的发生，很有可能消费者A读取了数据，还没来得及消费，就挂掉了。Zookeeper发现消费者A挂了，让消费者B去消费原本消费者A的分区，等消费者A重连的时候，发现已经重复消费同一条数据了。(各种各样的情况，消费者超时等等都有可能…)</p> <p>如果业务上不允许重复消费的问题，最好消费者那端做业务上的校验（如果已经消费过了，就不消费了）</p></li></ul> <h2 id="kafka为什么这么快"><a href="#kafka为什么这么快" class="header-anchor">#</a> Kafka为什么这么快</h2> <ul><li><code>顺序写</code></li></ul> <p>虽然说Kafka中的数据持久到到磁盘中，磁盘读写速度比不上内存读写速度。</p> <p>都知道完成一次磁盘io，需要经过寻道、旋转和读写数据。</p> <p>因为Kafka中某一个分区内的数据是有序的，队列FIFO，所以可以采用顺序写的方式进行持久化。</p> <p>Kafka采用顺序写的方式，来省去寻道和旋转产生的时间，从而提高写入磁盘的速度。</p> <p>每一个分区（Partition）对应多个物理文件（Segment）。</p> <ul><li><code>零拷贝</code></li></ul> <p>消费者读取磁盘中的数据，使用传统的IO模型，需要拷贝四次</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227114404871.png" alt="image-20230227114404871"></p> <p>零拷贝方式，减少用户态和内核态直接的切换</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227114649861.png" alt="image-20230227114649861"></p> <ul><li><code>PageCache</code></li></ul> <p>生产者生产消息到Broker时，先写入到page cache中，page cache存在内存当中，但不受jvm的GC管理，这样可以避免每次生产消费都需要磁盘io。</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227120624806.png" alt="image-20230227120624806"></p> <ul><li><code>网络模型</code></li></ul> <p>采用基于池化思想，避免为每个连接创建线程，连接完成后将业务处理交给线程池处理。</p> <p>基于 IO 复用模型，多个连接共用同一个阻塞对象，不用等待所有的连接。</p> <ul><li><code>批量与压缩</code></li></ul> <p>生产者向Broker发送消息是按照批量来发送，假设带宽是10MB/s，那么发送一个10MB的消息比发送1MB的消息10次要快。</p> <p>多数情况下，系统的瓶颈不在磁盘IO，而是在网络IO。</p> <ul><li><code>分区并发</code></li></ul> <p>Kafka的message是按topic分类存储的，topic中的数据又是按照一个一个的partition即分区存储到不同broker节点。</p> <p>每个partition对应了操作系统上的一个文件夹，partition实际上又是按照segment分段存储的。每次文件操作也是直接操作segment。</p> <p>为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件。</p> <h2 id="夺命连环问"><a href="#夺命连环问" class="header-anchor">#</a> 夺命连环问</h2> <h3 id="说说你对kafka的理解"><a href="#说说你对kafka的理解" class="header-anchor">#</a> 说说你对Kafka的理解</h3> <blockquote><p>Kafka是一个流式数据处理平台，具有消息系统的能力，也有实时流式数据处理分析能能力，只是我们通常把它当做消息队列系统来用。</p> <p>主要由三个方面组成，ZooKeeper、Kafka核心和存储。</p> <p>Kafka一般作为分布式系统来用，所以需要每个Kafka服务器启动时需要将自己注册到ZooKeeper中，由ZooKeeper来统一管理。</p> <p>然后Kafka本身，有消息、话题、生产者、消费者、分片、Broker、组等等。</p> <p>最后是存储方面，用来持久化存储Kafka的数据，都会以日志的形式最终存入到磁盘中。</p></blockquote> <h3 id="消息队列模型知道吗-kafka是怎么做到支持这两种模型的"><a href="#消息队列模型知道吗-kafka是怎么做到支持这两种模型的" class="header-anchor">#</a> 消息队列模型知道吗？kafka是怎么做到支持这两种模型的？</h3> <blockquote><p><code>点对点</code>：消息只能被一个消费者消费，消费完后消息删除。</p> <p><code>发布订阅</code>：相当于广播模式，消息可以被所有消费者消费。</p> <p>消费者组，由多个消费者组成，一个组内只会由一个消费者去消费一个分区的消息。</p></blockquote> <h3 id="能说说kafka通信过程原理吗"><a href="#能说说kafka通信过程原理吗" class="header-anchor">#</a> 能说说kafka通信过程原理吗？</h3> <blockquote><ol><li>首先Kafka Broker启动时，将自己注册到ZooKeeper中；</li> <li>生产者根据配置的地址连接到指定的Broker，建立TCP连接；</li> <li>发送消息；</li> <li>消费者和协调者Broker创建TCP连接；</li> <li>开始消费消息。</li></ol></blockquote> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230227152322197.png" alt="image-20230227152322197"></p> <h3 id="发送消息时如何选择分区的"><a href="#发送消息时如何选择分区的" class="header-anchor">#</a> 发送消息时如何选择分区的？</h3> <blockquote><ol><li>轮询，按照顺序消息依次发送到不同的分区</li> <li>随机，随机发送到某个分区</li></ol> <p>如果消息指定key，那么会根据消息的key进行hash，然后对partition分区数量取模，决定落在哪个分区上，所以，对于相同key的消息来说，总是会发送到同一个分区上，也是我们常说的消息分区有序性。</p> <p>很常见的场景就是我们希望下单、支付消息有顺序，这样以订单ID作为key发送消息就达到了分区有序性的目的。</p> <p>如果没有指定key，会执行默认的轮询负载均衡策略，比如第一条消息落在P0，第二条消息落在P1，然后第三条又在P1。</p> <p>除此之外，对于一些特定的业务场景和需求，还可以通过实现<code>Partitioner</code>接口，重写<code>configure</code>和<code>partition</code>方法来达到自定义分区的效果。</p></blockquote> <h3 id="为什么需要分区-有什么好处"><a href="#为什么需要分区-有什么好处" class="header-anchor">#</a> 为什么需要分区？有什么好处？</h3> <blockquote><p>如果说不分区的话，我们发消息写数据都只能保存到一个节点上，这样的话就算这个服务器节点性能再好最终也支撑不住。</p> <p>分区带来了负载均衡和横向扩展的能力。</p> <p>发送消息时可以根据分区的数量存在不同的Broker上，提升了并发读写消息能力。</p></blockquote> <h3 id="详细说说消费者组和消费者重平衡"><a href="#详细说说消费者组和消费者重平衡" class="header-anchor">#</a> 详细说说消费者组和消费者重平衡？</h3> <blockquote><p>一般来说，消费者数量和所有主题分区的数量保持一致最好，消费者组可以让Kafka支持传统的两种消息队列模型。</p> <p>Kafka中有一个协调者来 完成分区的分配，而重平衡Rebalance就是指的有新消费者加入的情况，比如刚开始我们只有消费者A在消费消息，过了一段时间消费者B和C加入了，这时候分区就需要重新分配。</p></blockquote> <h3 id="分区分配策略"><a href="#分区分配策略" class="header-anchor">#</a> 分区分配策略？</h3> <blockquote><p><strong>Range</strong></p> <p>对同一个主题的分区，排序优先均匀分给前面的消费者，排在前面的消费者获得的消息 &gt;= 后面的消费者。</p> <p><strong>RoundRobin</strong></p> <p>轮询，按顺序以此分配给消费者。</p> <p><strong>Sticky</strong></p> <p>之前这个分区 分给消费者，那么下次还是尽量分给他，避免频繁的销毁创建连接。</p></blockquote> <h3 id="消息传递语义剖析"><a href="#消息传递语义剖析" class="header-anchor">#</a> 消息传递语义剖析</h3> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230228085755025.png" alt="image-20230228085755025"></p> <blockquote><p>1）首先当 Producer 向 Broker 发送数据后，会进行 commit，如果commit成功，由于 Replica 副本机制的存在，则意味着消息不会丢失，但是 Producer 发送数据给 Broker 后，遇到网络问题而造成通信中断，那么 Producer 就无法准确判断该消息是否已经被提交（commit），这就可能造成 at least once 语义。</p> <p>2）在 Kafka 0.11.0.0 之前， 如果 Producer 没有收到消息 commit 的响应结果，它只能重新发送消息，确保消息已经被正确的传输到 Broker，重新发送的时候会将消息再次写入日志中；而在 0.11.0.0 版本之后， Producer 支持幂等传递选项，保证重新发送不会导致消息在日志出现重复。为了实现这个, Broker 为 Producer 分配了一个ID，并通过每条消息的序列号进行去重。也支持了类似事务语义来保证将消息发送到多个 Topic 分区中，保证所有消息要么都写入成功，要么都失败，这个主要用在 Topic 之间的 exactly once 语义。</p> <p><strong>其中启用幂等传递的方法配置</strong>：enable.idempotence = true。</p> <p><strong>启用事务支持的方法配置</strong>：设置属性 transcational.id = &quot;指定值&quot;。</p> <p>3）从 Consumer 角度来剖析, 我们知道 Offset 是由 Consumer 自己来维护的, 如果 Consumer 收到消息后更新 Offset， 这时 Consumer 异常 crash 掉， 那么新的 Consumer 接管后再次重启消费，就会造成 at most once 语义（消息会丢，但不重复）。</p> <p>4）如果 Consumer 消费消息完成后, 再更新 Offset，如果这时 Consumer crash 掉，那么新的 Consumer 接管后重新用这个 Offset 拉取消息， 这时就会造成 at least once 语义（消息不丢，但被多次重复处理）。</p></blockquote> <h3 id="kafka三次消息传递"><a href="#kafka三次消息传递" class="header-anchor">#</a> Kafka三次消息传递</h3> <blockquote><p>1）Producer 端发送消息给 Kafka Broker 端。</p> <p>2）Kafka Broker 将消息进行同步并持久化数据。</p> <p>3）Consumer 端从Kafka Broker 将消息拉取并进行消费。</p></blockquote> <p>Kafka 只对「<strong>已提交</strong>」的消息做「<strong>最大限度的持久化保证不丢失</strong>」<strong>。</strong></p> <p><strong>已提交</strong>的数据指Producer段发送的消息已经有<strong>N</strong>个Broker成功收到了，而且至少有一个Broker存活，那么就能保证消息持久化保证不丢失。</p> <h3 id="消息丢失场景"><a href="#消息丢失场景" class="header-anchor">#</a> 消息丢失场景</h3> <h4 id="producer端"><a href="#producer端" class="header-anchor">#</a> Producer端</h4> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230228090806497.png" alt="image-20230228090806497"></p> <blockquote><p>1）首先我们要知道一点就是Producer 端是直接与 Broker 中的 Leader Partition 交互的，所以在 Producer 端初始化中就需要通过 Partitioner 分区器从 Kafka 集群中获取到相关 Topic 对应的 Leader Partition 的元数据。</p> <p>2）待获取到 Leader Partition 的元数据后直接将消息发送过去。</p> <p>3）Kafka Broker 对应的 Leader Partition 收到消息会先写入 Page Cache，定时刷盘进行持久化（顺序写入磁盘）。</p> <p>4）Follower Partition 拉取 Leader Partition 的消息并保持同 Leader Partition 数据一致，待消息拉取完毕后需要给 Leader Partition 回复 ACK 确认消息。</p> <p>5）待 Kafka Leader 与 Follower Partition 同步完数据并收到所有 ISR 中的 Replica 副本的 ACK 后，Leader Partition 会给 Producer 回复 ACK 确认消息。</p></blockquote> <p>丢失情况可能发生在Producer端异步发送消息给Broker</p> <ul><li><strong>网络原因：</strong> 由于网络抖动导致数据没有发送过去</li> <li>**数据原因：**消息体太大超出Broker接收范围</li></ul> <p>通过配置参数来确认消息是否发送成功</p> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230228091555181.png" alt="image-20230228091555181"></p> <h4 id="broker端"><a href="#broker端" class="header-anchor">#</a> Broker端</h4> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230228091748206.png" alt="image-20230228091748206"></p> <p>KafkaBroker 集群接收到数据后会将数据进行持久化存储到磁盘，为了提高吞吐量和性能，采用的是「<strong>异步批量刷盘的策略</strong>」，也就是说按照一定的消息量和间隔时间进行刷盘。首先会将数据存储到 「<strong>PageCache</strong>」 中，至于什么时候将 Cache 中的数据刷盘是由「<strong>操作系统</strong>」根据自己的策略决定或者调用 fsync 命令进行强制刷盘，如果此时 Broker 宕机 Crash 掉，且选举了一个落后 Leader Partition 很多的 Follower Partition 成为新的 Leader Partition，那么落后的消息数据就会丢失。</p> <h4 id="consumer端"><a href="#consumer端" class="header-anchor">#</a> Consumer端</h4> <p><img src="https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230228092113890.png" alt="image-20230228092113890"></p> <blockquote><p>1）Consumer 拉取数据之前跟Producer 发送数据一样, 需要通过订阅关系获取到集群元数据,找到相关 Topic 对应的 Leader Partition 的元数据。</p> <p>2）然后 Consumer 通过 Pull 模式主动的去 Kafka 集群中拉取消息。</p> <p>3）在这个过程中，有个消费者组的概念（<strong>不了解的可以看上面链接文章</strong>），多个 Consumer 可以组成一个消费者组即 Consumer Group，每个消费者组都有一个Group-Id。同一个 Consumer Group 中的 Consumer 可以消费同一个 Topic 下不同分区的数据，但是不会出现多个 Consumer 去消费同一个分区的数据。</p> <p>4）拉取到消息后进行业务逻辑处理，待处理完成后，会进行 ACK 确认，即提交 Offset 消费位移进度记录。</p> <p>5）最后 Offset 会被保存到 Kafka Broker 集群中的 <strong>__consumer_offsets</strong> 这个 Topic 中，且每个 Consumer 保存自己的 Offset 进度。</p></blockquote> <p>Consumer拉取后消息最终是要提交Offset，那么这里就可能会丢失数据</p> <ul><li><p>可能使用的「<strong>自动提交 Offset 方式</strong>」</p></li> <li><p>拉取消息后「<strong>先提交 Offset，后处理消息</strong>」，如果此时处理消息的时候异常宕机，由于 Offset 已经提交了, 待 Consumer 重启后，会从之前已提交的 Offset 下一个位置重新开始消费， 之前未处理完成的消息不会被再次处理，对于该 Consumer 来说消息就丢失了。</p></li> <li><p>拉取消息后「<strong>先处理消息，在进行提交 Offset</strong>」， 如果此时在提交之前发生异常宕机，由于没有提交成功 Offset， 待下次 Consumer 重启后还会从上次的 Offset 重新拉取消息，不会出现消息丢失的情况， 但是会出现重复消费的情况，这里只能业务自己保证幂等性。</p></li></ul> <h4 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h4> <p>发送的调用方式改为异步方式</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RecordMetadata</span><span class="token punctuation">&gt;</span></span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> record<span class="token punctuation">,</span> <span class="token class-name">Callback</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RecordMetadata</span><span class="token punctuation">&gt;</span></span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> record<span class="token punctuation">,</span> <span class="token class-name">Callback</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">//intercept the record, which can be potentially modified; this method does not throw exceptions </span>
    <span class="token class-name">ProducerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> interceptedRecord <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>interceptors <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> record <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span><span class="token function">onSend</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> <span class="token function">doSend</span><span class="token punctuation">(</span>interceptedRecord<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>


</code></pre></div><p>然后就是修改一些配置项</p> <p>producer端发送消息重试次数，retries 设为最大值；</p> <p>重试时间retry.backoff.ms 设为300ms；</p> <p>unclean.leader.election.enable ，false表示不要在ISR列表外的follow选举leader，因为那些副本落后原来leader很多；</p> <p>replication.factor，设置分区副本的个数，&gt;=3；</p> <p>min.insync.replicas，ISR个数，也是“已提交”个数；</p> <p>enable.auto.commit = false，设置消费端手动移位offset，业务自己保证幂等性。</p></div></div>  <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/467ce0/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">ZooKeeper</div></a> <a href="/pages/2ca146/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">RabbitMQ</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/467ce0/" class="prev">ZooKeeper</a></span> <span class="next"><a href="/pages/2ca146/">RabbitMQ</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/4ce008/"><div>
            Controller接收请求方式
            <!----></div></a> <span class="date">08-10</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/7d963b/"><div>
            面试记录
            <!----></div></a> <span class="date">07-27</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/20b125/"><div>
            分布式共识Raft算法
            <!----></div></a> <span class="date">07-12</span></dt></dl> <dl><dd></dd> <dt><a href="/archives" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:895827938@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/lzxiaohuihui" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=782007907" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2023
    <span>Evan Xu | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.346e1551.js" defer></script><script src="/assets/js/2.2bb1a3f0.js" defer></script><script src="/assets/js/14.1e95b815.js" defer></script>
  </body>
</html>
