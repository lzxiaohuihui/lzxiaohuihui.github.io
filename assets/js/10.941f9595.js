(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{339:function(t,a,s){"use strict";s.r(a);var e=s(3),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("h3",{attrs:{id:"线程池是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程池是什么"}},[t._v("#")]),t._v(" 线程池是什么")]),t._v(" "),a("p",[t._v("线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。")]),t._v(" "),a("p",[t._v("使用线程池可以带来一系列好处：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("降低资源消耗")]),t._v("：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。")]),t._v(" "),a("li",[a("strong",[t._v("提高响应速度")]),t._v("：任务到达时，无需等待线程创建即可立即执行。")]),t._v(" "),a("li",[a("strong",[t._v("提高线程的可管理性")]),t._v("：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。")]),t._v(" "),a("li",[a("strong",[t._v("提供更多更强大的功能")]),t._v("：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。")])]),t._v(" "),a("h3",{attrs:{id:"线程池解决的问题是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程池解决的问题是什么"}},[t._v("#")]),t._v(" 线程池解决的问题是什么")]),t._v(" "),a("ol",[a("li",[t._v("频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。")]),t._v(" "),a("li",[t._v("对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。")]),t._v(" "),a("li",[t._v("系统无法合理管理内部的资源分布，会降低系统的稳定性。")])]),t._v(" "),a("p",[t._v("除去线程池，还有其他比较典型的几种使用策略包括：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("内存池")]),t._v("(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。")]),t._v(" "),a("li",[a("strong",[t._v("连接池")]),t._v("(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。")]),t._v(" "),a("li",[a("strong",[t._v("实例池")]),t._v("(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。")])]),t._v(" "),a("h2",{attrs:{id:"线程池的核心设计与实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程池的核心设计与实现"}},[t._v("#")]),t._v(" 线程池的核心设计与实现")]),t._v(" "),a("h3",{attrs:{id:"jdk1-8中主要的类图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-8中主要的类图"}},[t._v("#")]),t._v(" JDK1.8中主要的类图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230330095530350.png",alt:"image-20230330095530350"}})]),t._v(" "),a("p",[t._v("顶层接口"),a("strong",[t._v("Executor")]),t._v("提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。")]),t._v(" "),a("p",[a("strong",[t._v("ExecutorService")]),t._v("是一个接口，扩展了Executor接口，定义了一些方法，例如submit()、shutdown()、shutdownNow()等，用于管理和控制线程池中的任务。")]),t._v(" "),a("p",[a("strong",[t._v("AbstractExecutorService")]),t._v("是一个抽象类，实现了ExecutorService接口中的大部分方法，但留下了一些抽象方法供子类实现。它提供了一些默认的行为，例如如何处理被拒绝的任务等。")]),t._v(" "),a("p",[t._v("最下层的实现类"),a("strong",[t._v("ThreadPoolExecutor")]),t._v("实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230330100411276.png",alt:"image-20230330100411276"}})]),t._v(" "),a("h3",{attrs:{id:"生命周期管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期管理"}},[t._v("#")]),t._v(" 生命周期管理")]),t._v(" "),a("p",[t._v("线程池内部使用一个变量维护两个值：运行状态（runState）和线程数量（workerCount）。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),t._v(" ctl "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ctlOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RUNNING")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。")]),t._v(" "),a("p",[t._v("ThreadPoolExecutor的运行状态有5种，分别为：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("运行状态")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("状态描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("RUNNING")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("能接受新提交的任务，并且也能处理阻塞队列中的任务")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("SHUTDOWN")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("关闭状态，不在接受新提交的任务，但可以继续处理阻塞队列中已保存的任务")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("STOP")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("不能接收新任务，也不处理队列中的任务，会中断正在处理任务的线程")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("TIDYING")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("所有的任务都已终止，workerCount(有效线程数)为0")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("TERMINATED")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("在terminated()方法执行完后进入该状态")])])])]),t._v(" "),a("p",[t._v("其生命周期转换如下入所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230330101709475.png",alt:"image-20230330101709475"}})]),t._v(" "),a("h3",{attrs:{id:"任务执行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务执行机制"}},[t._v("#")]),t._v(" 任务执行机制")]),t._v(" "),a("h4",{attrs:{id:"任务调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务调度"}},[t._v("#")]),t._v(" 任务调度")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230330101948137.png",alt:"image-20230330101948137"}})]),t._v(" "),a("h4",{attrs:{id:"任务缓冲"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务缓冲"}},[t._v("#")]),t._v(" 任务缓冲")]),t._v(" "),a("p",[t._v("阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230330102608892.png",alt:"image-20230330102608892"}})]),t._v(" "),a("h4",{attrs:{id:"任务申请"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务申请"}},[t._v("#")]),t._v(" 任务申请")]),t._v(" "),a("p",[t._v("任务的执行有两种可能：")]),t._v(" "),a("ul",[a("li",[t._v("任务直接由新创建的线程执行。")]),t._v(" "),a("li",[t._v("线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/49d8041f8480aba5ef59079fcc7143b996706.png",alt:"图6 获取任务流程图"}})]),t._v(" "),a("h4",{attrs:{id:"任务拒绝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务拒绝"}},[t._v("#")]),t._v(" 任务拒绝")]),t._v(" "),a("p",[t._v("任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到"),a("code",[t._v("maximumPoolSize")]),t._v("时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。")]),t._v(" "),a("p",[t._v("可以实现这个接口定制拒绝策略")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RejectedExecutionHandler")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("rejectedExecution")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runnable")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadPoolExecutor")]),t._v(" executor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("JDK中提供了四种拒绝策略")]),t._v(" "),a("ol",[a("li",[t._v("AbortPolicy：默认的拒绝策略，当线程池无法处理新的任务时，直接抛出RejectedExecutionException异常。")]),t._v(" "),a("li",[t._v("CallerRunsPolicy：当线程池无法处理新的任务时，将任务返回给调用者，由调用者线程执行。")]),t._v(" "),a("li",[t._v("DiscardPolicy：当线程池无法处理新的任务时，直接丢弃该任务，不做任何处理。")]),t._v(" "),a("li",[t._v("DiscardOldestPolicy：当线程池无法处理新的任务时，丢弃队列中最老的任务，然后将新的任务加入队列。")])]),t._v(" "),a("h3",{attrs:{id:"worker线程管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#worker线程管理"}},[t._v("#")]),t._v(" Worker线程管理")]),t._v(" "),a("h4",{attrs:{id:"worker线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#worker线程"}},[t._v("#")]),t._v(" Worker线程")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Worker")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbstractQueuedSynchronizer")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runnable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" thread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Worker持有的线程")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runnable")]),t._v(" firstTask"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//初始化的任务，可以为null")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。")]),t._v(" "),a("p",[t._v("这个时候重要的就是如何判断线程"),a("strong",[t._v("是否在运行")]),t._v("。")]),t._v(" "),a("p",[t._v("Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("lock方法一旦获取了独占锁，表示当前线程正在执行任务中。")])]),t._v(" "),a("li",[a("p",[t._v("如果正在执行任务，则不应该中断线程。")])]),t._v(" "),a("li",[a("p",[t._v("如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。")])]),t._v(" "),a("li",[a("p",[t._v("线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。")])])]),t._v(" "),a("h4",{attrs:{id:"worker线程增加"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#worker线程增加"}},[t._v("#")]),t._v(" Worker线程增加")]),t._v(" "),a("p",[t._v("增加线程是通过线程池中的addWorker方法，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。")]),t._v(" "),a("h4",{attrs:{id:"worker线程回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#worker线程回收"}},[t._v("#")]),t._v(" Worker线程回收")]),t._v(" "),a("p",[t._v("Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，"),a("strong",[t._v("核心线程")]),t._v("可以无限等待获取任务，"),a("strong",[t._v("非核心线程")]),t._v("要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230330111057040.png",alt:"image-20230330111057040"}})]),t._v(" "),a("h4",{attrs:{id:"worker线程执行任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#worker线程执行任务"}},[t._v("#")]),t._v(" Worker线程执行任务")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/879edb4f06043d76cea27a3ff358cb1d45243.png",alt:"图11 执行任务流程"}})]),t._v(" "),a("h2",{attrs:{id:"线程池在业务中的实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程池在业务中的实践"}},[t._v("#")]),t._v(" 线程池在业务中的实践")]),t._v(" "),a("h3",{attrs:{id:"场景1-快速响应用户请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景1-快速响应用户请求"}},[t._v("#")]),t._v(" 场景1：快速响应用户请求")]),t._v(" "),a("p",[t._v("用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230330122858844.png",alt:"image-20230330122858844"}})]),t._v(" "),a("h3",{attrs:{id:"场景2-快速处理批量任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#场景2-快速处理批量任务"}},[t._v("#")]),t._v(" 场景2：快速处理批量任务")]),t._v(" "),a("p",[t._v("离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230330130700193.png",alt:"image-20230330130700193"}})]),t._v(" "),a("h3",{attrs:{id:"实际问题及方案思考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实际问题及方案思考"}},[t._v("#")]),t._v(" 实际问题及方案思考")])])}),[],!1,null,null,null);a.default=r.exports}}]);