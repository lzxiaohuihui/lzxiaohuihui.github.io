(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{348:function(s,e,a){"use strict";a.r(e);var v=a(3),t=Object(v.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("p",[e("strong",[s._v("基于Redis集群解决单机Redis存在的问题")])]),s._v(" "),e("blockquote",[e("ol",[e("li",[s._v("数据丢失问题：实现Redis数据持久化")]),s._v(" "),e("li",[s._v("并发能力问题：搭建主从集群，实现读写分离")]),s._v(" "),e("li",[s._v("故障恢复问题：利用Redis哨兵，实现健康检测和自动恢复")]),s._v(" "),e("li",[s._v("存储能力问题：搭建分片集群，动态扩容")])])]),s._v(" "),e("h2",{attrs:{id:"redis持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化"}},[s._v("#")]),s._v(" Redis持久化")]),s._v(" "),e("h3",{attrs:{id:"rdb持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化"}},[s._v("#")]),s._v(" RDB持久化")]),s._v(" "),e("p",[s._v("RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。")]),s._v(" "),e("p",[e("strong",[s._v("执行时机")])]),s._v(" "),e("ul",[e("li",[s._v("执行save命令")])]),s._v(" "),e("p",[s._v("save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。")]),s._v(" "),e("ul",[e("li",[s._v("执行bgsave命令")])]),s._v(" "),e("p",[s._v("这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。")]),s._v(" "),e("ul",[e("li",[s._v("Redis停机时")])]),s._v(" "),e("p",[s._v("Redis停机时会执行一次save命令，实现RDB持久化。")]),s._v(" "),e("ul",[e("li",[s._v("触发RDB条件时")])]),s._v(" "),e("p",[s._v("redis.conf配置触发RDB机制，可以配置多久内有多少个key发生变更，则执行"),e("strong",[s._v("bgsave")]),s._v("命令")]),s._v(" "),e("p",[s._v("bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。")]),s._v(" "),e("p",[s._v("fork采用的是copy-on-write技术：")]),s._v(" "),e("ul",[e("li",[s._v("当主进程执行读操作时，访问共享内存；")]),s._v(" "),e("li",[s._v("当主进程执行写操作时，则会拷贝一份数据，执行写操作。")])]),s._v(" "),e("p",[e("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230301145721653.png",alt:"image-20230301145721653"}})]),s._v(" "),e("h3",{attrs:{id:"aof持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化"}},[s._v("#")]),s._v(" AOF持久化")]),s._v(" "),e("p",[s._v("AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230301153810060.png",alt:"image-20230301153810060"}})]),s._v(" "),e("h2",{attrs:{id:"redis主从"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis主从"}},[s._v("#")]),s._v(" Redis主从")]),s._v(" "),e("p",[s._v("单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230301153851976.png",alt:"image-20230301153851976"}})]),s._v(" "),e("h3",{attrs:{id:"全量同步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全量同步"}},[s._v("#")]),s._v(" 全量同步")]),s._v(" "),e("p",[s._v("主从第一次建立连接时，会执行"),e("strong",[s._v("全量同步")]),s._v("，将master节点的所有数据都拷贝给slave节点，流程：")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230302102200487.png",alt:"image-20230302102200487"}})]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("Replication Id")]),s._v("：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid")]),s._v(" "),e("li",[e("strong",[s._v("offset")]),s._v("：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。")])]),s._v(" "),e("p",[s._v("因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。")]),s._v(" "),e("p",[s._v("因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。")]),s._v(" "),e("p",[s._v("master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。")]),s._v(" "),e("p",[s._v("master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。")]),s._v(" "),e("p",[s._v("因此，"),e("strong",[s._v("master判断一个节点是否是第一次同步的依据，就是看replid是否一致")]),s._v("。")]),s._v(" "),e("h3",{attrs:{id:"增量同步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#增量同步"}},[s._v("#")]),s._v(" 增量同步")]),s._v(" "),e("p",[s._v("除了第一次做全量同步，其它大多数时候slave与master都是做增量同步。")]),s._v(" "),e("p",[e("strong",[s._v("当大哥收到数据变更的命令时，以及每隔一段时间，将消息通知小弟来我这复制。")])]),s._v(" "),e("p",[e("img",{attrs:{src:"/home/lzh/.config/Typora/typora-user-images/image-20230302102359765.png",alt:"image-20230302102359765"}})]),s._v(" "),e("p",[e("strong",[s._v("repl_baklog")])]),s._v(" "),e("p",[s._v("slave 的offset 不断"),e("strong",[s._v("追赶")]),s._v(" master 的offset")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230302102707824.png",alt:"image-20230302102707824"}})]),s._v(" "),e("p",[s._v("当master的offset 超过 slave的offset太多，那salve节点进行全量同步。")]),s._v(" "),e("h2",{attrs:{id:"redis哨兵"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis哨兵"}},[s._v("#")]),s._v(" Redis哨兵")]),s._v(" "),e("p",[s._v("Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230302110538214.png",alt:"image-20230302110538214"}})]),s._v(" "),e("p",[s._v("哨兵的作用如下：")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("监控")]),s._v("：Sentinel 会不断检查您的master和slave是否按预期工作")]),s._v(" "),e("li",[e("strong",[s._v("自动故障恢复")]),s._v("：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主")]),s._v(" "),e("li",[e("strong",[s._v("通知")]),s._v("：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端")])]),s._v(" "),e("h3",{attrs:{id:"监控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#监控"}},[s._v("#")]),s._v(" 监控")]),s._v(" "),e("p",[s._v("Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：")]),s._v(" "),e("p",[s._v("•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例"),e("strong",[s._v("主观下线")]),s._v("。")]),s._v(" "),e("p",[s._v("•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例"),e("strong",[s._v("客观下线")]),s._v("。quorum值最好超过Sentinel实例数量的一半。")]),s._v(" "),e("h3",{attrs:{id:"故障恢复"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#故障恢复"}},[s._v("#")]),s._v(" 故障恢复")]),s._v(" "),e("p",[s._v("一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：")]),s._v(" "),e("ul",[e("li",[s._v("首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点")]),s._v(" "),e("li",[s._v("然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举")]),s._v(" "),e("li",[s._v("如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高")]),s._v(" "),e("li",[s._v("最后是判断slave节点的运行id大小，越小优先级越高。")])]),s._v(" "),e("p",[s._v("当选出一个新的master后，该如何实现切换呢？")]),s._v(" "),e("p",[s._v("流程如下：")]),s._v(" "),e("ul",[e("li",[s._v("sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master")]),s._v(" "),e("li",[s._v("sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。")]),s._v(" "),e("li",[s._v("最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点")])]),s._v(" "),e("h2",{attrs:{id:"redis分片集群"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis分片集群"}},[s._v("#")]),s._v(" Redis分片集群")]),s._v(" "),e("p",[s._v("主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("海量数据存储问题")])]),s._v(" "),e("li",[e("p",[s._v("高并发写的问题")])])]),s._v(" "),e("p",[s._v("使用分片集群可以解决上述问题，如图:")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230302112321147.png",alt:"image-20230302112321147"}})]),s._v(" "),e("p",[s._v("分片集群特征：")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("集群中有多个master，每个master保存不同数据")])]),s._v(" "),e("li",[e("p",[s._v("每个master都可以有多个slave节点")])]),s._v(" "),e("li",[e("p",[s._v("master之间通过ping监测彼此健康状态")])]),s._v(" "),e("li",[e("p",[s._v("客户端请求可以访问集群任意节点，最终都会被转发到正确节点")])])])])}),[],!1,null,null,null);e.default=t.exports}}]);