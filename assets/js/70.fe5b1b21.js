(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{399:function(a,t,_){"use strict";_.r(t);var i=_(3),v=Object(i.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"_2019-mapping-and-locatization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2019-mapping-and-locatization"}},[a._v("#")]),a._v(" 2019 mapping and locatization")]),a._v(" "),t("p",[a._v("利用道路标记语义分割解决长期高精度视觉定位问题。")]),a._v(" "),t("p",[a._v("结合语义与几何的点云配准方法。")]),a._v(" "),t("p",[a._v("全球导航卫星系统（GNSS）。雷达、UWB技术虽然有高精度定位，但价格昂高。")]),a._v(" "),t("p",[a._v("近年目标检测，语义分割提供了很多语义信息，这可以整合到建图和定位的过程中。")]),a._v(" "),t("p",[a._v("通常部署环视摄像机以提高对遮挡的鲁棒性。")]),a._v(" "),t("p",[a._v("[17] 中提出了使用 ID 进行停车位检测的尝试，他们将 ID 视为语义数据关联，并应用视觉基准标签来辅助闭环，从而获得更高的精度。(没有充分利用车道线信息)")]),a._v(" "),t("p",[a._v("Road-SLAM [18] 中的工作对道路标记的点云进行分割和分类，然后使用道路标记匹配执行闭环，从而获得米级定位精度。")]),a._v(" "),t("blockquote",[t("ol",[t("li",[a._v("使用生成的点云，融合模块被设计来构建用于匹配的局部子图。")]),a._v(" "),t("li",[a._v("为了纠正航位推算误差累积，采用基于分割结果的闭环检测重访位置。")]),a._v(" "),t("li",[a._v("依次应用位姿图优化和点云校正以保证全局一致性。")]),a._v(" "),t("li",[a._v("在定位过程中，进行全局初始化，将当前局部坐标与地图坐标对齐。")]),a._v(" "),t("li",[a._v("为了提高匹配精度，提出了基于语义和几何信息的ICP来匹配语义点云和当前子图，并使用扩展卡尔曼滤波器（EKF）算法与航位推算融合，实现高精度定位，无漂移积累 .")])])]),a._v(" "),t("h3",{attrs:{id:"使用标记道路建图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用标记道路建图"}},[a._v("#")]),a._v(" 使用标记道路建图")]),a._v(" "),t("blockquote",[t("ol",[t("li",[a._v("首先进行语义分割和IPM，将相机图像转换为单帧点云。")]),a._v(" "),t("li",[a._v("然后，提出了航位推算（IMU、轮速里程计）辅助的图像拼接和语义道路标记辅助的点云融合，以减少时间不同步和误分类的影响，构建准确的局部子地图。")]),a._v(" "),t("li",[a._v("为了获得全局一致的地图，设计了基于道路标记分割的闭环来检测重访区域。")]),a._v(" "),t("li",[a._v("最后，基于闭环结果，我们采用全局姿态图优化来确保所有姿态的一致性。")])])]),a._v(" "),t("h3",{attrs:{id:"生成点云"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成点云"}},[a._v("#")]),a._v(" 生成点云")]),a._v(" "),t("blockquote",[t("ol",[t("li",[a._v("这里使用多类点云，根据原始的鱼眼相机图像，进行语义分割，将道路标记分为七类。")]),a._v(" "),t("li",[a._v("创建鸟瞰图。")]),a._v(" "),t("li",[a._v("基于鸟瞰图，通过提取带有道路标记标签的像素来创建点云。")]),a._v(" "),t("li",[a._v("由于四个鱼眼相机的时间难以同步，使用IMU和轮速里程计来补偿拼接误差。")]),a._v(" "),t("li",[a._v("为了确保点云配准算法保持恒定的计算复杂度，我们随机删除一些点以限制在单帧中观察到的点数。")])])]),a._v(" "),t("h3",{attrs:{id:"点云融合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#点云融合"}},[a._v("#")]),a._v(" 点云融合")]),a._v(" "),t("p",[a._v("确定数据关联，设计合适的策略融合点云。")]),a._v(" "),t("p",[a._v("对于给定的关联，没有找到相应匹配点的点直接添加到地图中。没有关联的按以下方式融合")]),a._v(" "),t("p",[a._v("自己看去。")]),a._v(" "),t("h3",{attrs:{id:"回环检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回环检测"}},[a._v("#")]),a._v(" 回环检测")]),a._v(" "),t("p",[a._v("通过 FAST方向 和旋转(ORB) 描述符和语义描述符，给出闭环候选，然后通过DBoW2模块计算词袋向量，最后计算关联得分分数。")]),a._v(" "),t("h1",{attrs:{id:"_2020-avp-slam"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2020-avp-slam"}},[a._v("#")]),a._v(" 2020  AVP-SLAM")]),a._v(" "),t("p",[a._v("在停车场工厂这样的环境，使用传统的几何特征几乎不切实际，会频繁的跟踪丢失。这里提出一种语义特征，可以很稳定的识别车道线，路标等，且不受视角和光线的影响。")]),a._v(" "),t("h3",{attrs:{id:"本文的主要工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本文的主要工作"}},[a._v("#")]),a._v(" 本文的主要工作：")]),a._v(" "),t("blockquote",[t("ol",[t("li",[a._v("提出在vslam中的语义特征。")]),a._v(" "),t("li",[a._v("提出完整的建图和定位系统。")]),a._v(" "),t("li",[a._v("构造真实的自动停车应用。")])])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lzxiaohuihui/piture_for_markdown/main/img/image-20211222101110801.png",alt:"image-20211222101110801"}})]),a._v(" "),t("p",[a._v("Get:")]),a._v(" "),t("blockquote",[t("ol",[t("li",[a._v("relative localization 也叫 odometry ， 一般先初始化开始的位置，然后关注当前帧的相对位姿。")]),a._v(" "),t("li",[a._v("global localization 有一个固定的坐标，通常通过一个先验地图进行定位。")]),a._v(" "),t("li",[a._v("传统的特征方法一般都是利用集合特征（稀疏点、角点和稠密的平面），这里只需要估计关键点的位置，这些关键点可以进一步添加一个补充区分，例如SFIT、SURF、ORB、BRIEF描述子。一般通过"),t("code",[a._v("提前")]),a._v("视觉里程计来构建视觉地图，然后在这个地图内对相机进行定位。例如ORB特征的地图，之后可以通过ORB描述子进行匹配来定位。")]),a._v(" "),t("li",[a._v("基于道路特征的方法一般采用道路表面的道路标志（车道线、路边和标志等）。可以使用额外的设备（激光雷达）提前构建好精确的地图，")])])]),a._v(" "),t("h3",{attrs:{id:"系统概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#系统概述"}},[a._v("#")]),a._v(" 系统概述")]),a._v(" "),t("blockquote",[t("ol",[t("li",[a._v("在前后左右使用分别安装相机，使用IMU和轮速里程计提供一个初始的相对位姿，但会存在累计误差。")]),a._v(" "),t("li",[a._v("首先构建一个全局的语义地图，使用神经网络提取语义特征（车道线、指示标志、减速带），因为存在累计误差，这里采用局部地图的回环检测减少误差。")]),a._v(" "),t("li",[a._v("其次进行定位，和建图部分差不多，后端采用EKF进行优化。")])])]),a._v(" "),t("h3",{attrs:{id:"ipm-image"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ipm-image"}},[a._v("#")]),a._v(" IPM Image")]),a._v(" "),t("p",[a._v("​\t\t将相机获取照片的像素点，投影到以车为中心的坐标系中。")]),a._v(" "),t("h3",{attrs:{id:"feature-detection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#feature-detection"}},[a._v("#")]),a._v(" Feature Detection")]),a._v(" "),t("p",[a._v("​\t\t使用主流的CNN方法取提取语义特征。大多数图像分割网络都可以。")]),a._v(" "),t("h3",{attrs:{id:"local-mapping"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#local-mapping"}},[a._v("#")]),a._v(" Local Mapping")]),a._v(" "),t("p",[a._v("​\t\t将上一步语义分割的点，基于里程计，转换到世界坐标系，这些点组成一个local map。")]),a._v(" "),t("h3",{attrs:{id:"loop-detection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loop-detection"}},[a._v("#")]),a._v(" Loop Detection")]),a._v(" "),t("p",[a._v("​\t\t因为里程计存在累计误差，这里使用回环检测来消除漂移。对于最新的local map，我们比较它周围的local map，这里两个local map通过ICP方法来匹配。如果有两个local maps匹配成功，计算一个相对位姿，然后放到全局位姿图优化器总进行优化，进而矫正漂移。")]),a._v(" "),t("h3",{attrs:{id:"global-optimization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#global-optimization"}},[a._v("#")]),a._v(" Global Optimization")]),a._v(" "),t("p",[a._v("​\t\t这里的位姿图中，节点是每一个local map的位姿，这里有两种边，一种是通过里程计测量两个local maps的相对位姿，另一种是回环检测边，约束形成闭环的local maps。")]),a._v(" "),t("h3",{attrs:{id:"localization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#localization"}},[a._v("#")]),a._v(" Localization")]),a._v(" "),t("p",[a._v("​\t\t基于已经构建好的语义地图，在车经过同样地方时可以定位。对于输入的合成图像，进行语义特征检测，转换到车的坐标系，然后通过"),t("code",[a._v("在地图中匹配车当前获取的语义特征")]),a._v("来估计车当前的位姿，这了使用ICP方法进行匹配")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lzxiaohuihui/piture_for_markdown/main/img/image-20211222151030032.png",alt:"image-20211222151030032"}})]),a._v(" "),t("p",[a._v("​\t\t绿色的是车当前获取的特征，橙色的估计的轨迹。")]),a._v(" "),t("p",[a._v("​\t\tICP方法的初始迭代值很重要，在最开始的初始化中，这里提供了两种方法，一是在停车场入口处放置标志，二是进入地下停车场前使用GPS给定在地图中的初始位置。在很少纹理的区域中，采用EKF，融合了里程计和视觉定位的结果，在过滤器中，里程计作为预测，视觉定位结果用来更新。")]),a._v(" "),t("h3",{attrs:{id:"parking-spot-detection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parking-spot-detection"}},[a._v("#")]),a._v(" Parking Spot Detection")]),a._v(" "),t("p",[a._v("​\t \t停车位的角点用来预测停车线位置，如果停车线能够匹配角点，那么这次预测是准确的。")]),a._v(" "),t("h1",{attrs:{id:"_2021-roadmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2021-roadmap"}},[a._v("#")]),a._v(" 2021 RoadMap")]),a._v(" "),t("p",[a._v("​\t\t车载测绘、云端维护、用户端定位的框架。在车辆上收集和预处理地图数据，将复杂的数据上传到云端，在云端整合多辆车的数据，并及时更新语义地图，最后经过压缩，分发到车辆中。提出一个新颖的想法，使用传感器丰富的车每天去收集数据和更新地图，最终受益于量产车上。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lzxiaohuihui/piture_for_markdown/main/img/image-20211222191237390.png",alt:"image-20211222191237390"}})]),a._v(" "),t("h3",{attrs:{id:"系统概述-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#系统概述-2"}},[a._v("#")]),a._v(" 系统概述")]),a._v(" "),t("blockquote",[t("ol",[t("li",[a._v("搭载前置摄像头，GPS，IMU和轮速里程计的车每天出去收集数据，前置摄像头收集的照片放到分割网络，提取语义特征，然后将语义特征转到到世界坐标系，最后建立局部地图，上传到云端。")]),a._v(" "),t("li",[a._v("云端收集到多辆上述的车的局部地图，融合成全局地图，然后对地图轮廓提取，最后将压缩后的语义地图发送给用户（量产车）。")]),a._v(" "),t("li",[a._v("用户端配备低成本传感器，下载云端的地图，然后进行定位。")])])]),a._v(" "),t("h3",{attrs:{id:"ipm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ipm"}},[a._v("#")]),a._v(" IPM")]),a._v(" "),t("p",[a._v("这里只对ROI的IPM，车前方12m * 8m。")]),a._v(" "),t("h3",{attrs:{id:"pose-graph-optimization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pose-graph-optimization"}},[a._v("#")]),a._v(" Pose Graph Optimization")]),a._v(" "),t("p",[a._v("虽然用上RTK-GNSS，厘米级精度，只能在空旷的区域。这里的位姿图优化也是有两种边，GNSS RTK对节点的约束，里程计对节点的约束。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lzxiaohuihui/piture_for_markdown/main/img/image-20211222195647021.png",alt:"image-20211222195647021"}})]),a._v(" "),t("h3",{attrs:{id:"local-map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#local-map"}},[a._v("#")]),a._v(" Local Map")]),a._v(" "),t("p",[a._v("同理，这里的语义特征都需要投影到全局坐标系中。这里语义特征分类用了窗口，当车移动时，一个区域可能会被观测多次，由于存在分割的噪声，这区域可能会被分为不同的类别。 使用统计过滤噪声。地图被分成许多的网络，当一个语义点进入一个网格，对应的语义标签加1，次数最多的语义代表这个网格。")]),a._v(" "),t("h3",{attrs:{id:"map-merging-updating"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map-merging-updating"}},[a._v("#")]),a._v(" Map Merging / Updating")]),a._v(" "),t("p",[a._v("为了节省带宽，这里只选择局部地图中被标记的网络进行上传到云端，同理云端的地图也分为若干个网格，局部地图网格中的标签得分也加到全局地图中。这个过程是并行的。")]),a._v(" "),t("h3",{attrs:{id:"map-compression"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map-compression"}},[a._v("#")]),a._v(" Map Compression")]),a._v(" "),t("p",[a._v("同样为了节省带宽，这里语义地图的可以被轮廓代表。首先，生成语义图的顶视图图像，每一个像素代表一个网格。其次，提取每一组语义的轮廓。最后，轮廓点存起来，发送到量产车。")]),a._v(" "),t("h3",{attrs:{id:"map-decompression"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map-decompression"}},[a._v("#")]),a._v(" Map Decompression")]),a._v(" "),t("p",[a._v("量产车拿到压缩后的数据后，进行解压：用相同标签的点，填充轮廓。")]),a._v(" "),t("h3",{attrs:{id:"icp-localization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#icp-localization"}},[a._v("#")]),a._v(" ICP Localization")]),a._v(" "),t("p",[a._v("恢复出语义地图后，同上一篇，使用ICP方法进行匹配，后端使用EKF融合里程计和视觉定位的信息，进行优化。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/lzxiaohuihui/piture_for_markdown/main/img/image-20211222204054118.png",alt:"image-20211222204054118"}})]),a._v(" "),t("p",[a._v("绿色的车当前获取到的语义特征。")]),a._v(" "),t("p",[a._v("实验中，还将语义地图与谷歌地图对齐。")])])}),[],!1,null,null,null);t.default=v.exports}}]);