(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{360:function(t,a,s){"use strict";s.r(a);var _=s(3),v=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("锁，固然是用来解决并发事务出现的问题的。")]),t._v(" "),a("h2",{attrs:{id:"全局锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[t._v("#")]),t._v(" 全局锁")]),t._v(" "),a("p",[t._v("同时需要备份多个表的数据，仅仅锁一张表是不够的，但是又比较鸡肋。")]),t._v(" "),a("p",[t._v("数据库备份，采用Read View方式进行备份即可。")]),t._v(" "),a("h2",{attrs:{id:"表锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[t._v("#")]),t._v(" 表锁")]),t._v(" "),a("p",[t._v("也就是正常理解的写锁和读锁，如果某事务要对表获取"),a("strong",[t._v("读")]),t._v("锁，那就得确保该表中所有的记录都没有"),a("strong",[t._v("写")]),t._v("锁。加表锁之前先遍历一遍表中的记录？遍历是不可能遍历的，这辈子都不可能遍历。")]),t._v(" "),a("div",{staticClass:"custom-block note"},[a("p",{staticClass:"custom-block-title"},[t._v("意向锁")]),t._v(" "),a("p",[t._v("所以这样设计，事务想对某条"),a("strong",[t._v("记录")]),t._v("上加锁时，先在"),a("strong",[t._v("表")]),t._v("上加个"),a("strong",[t._v("意向锁")]),t._v("。加意向锁并不关心这表先前有没有加过意向锁。释放记录上的锁时，同时释放自己加在表上的意向锁。")])]),t._v(" "),a("p",[t._v("这样新事务来想对表加锁，那么判断这表上有没有意向锁，如果有相应的意向锁，那么就会获取表锁失败，阻塞。")]),t._v(" "),a("hr"),t._v(" "),a("p",[a("strong",[t._v("AUTO-INC自增锁")])]),t._v(" "),a("p",[t._v("对于自增的列，系统会自动赋值。")]),t._v(" "),a("ul",[a("li",[t._v("采用AUTO-INC锁，执行插入语句时就在表上加一个AUTO-INC锁，分配自增的值，等执行完插入语句时把锁释放。")]),t._v(" "),a("li",[t._v("有一个轻量级锁，在给插入SQL语句生成自增值后，遍释放锁，无需等插入语句执行完。一般用在已知要插入多少条记录。")])]),t._v(" "),a("h2",{attrs:{id:"行锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[t._v("#")]),t._v(" 行锁")]),t._v(" "),a("p",[t._v("每一行记录后，会附加一个锁结构信息，用来表示该记录中锁的信息。")]),t._v(" "),a("h3",{attrs:{id:"gap-locks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gap-locks"}},[t._v("#")]),t._v(" Gap Locks：")]),t._v(" "),a("p",[t._v("因为先前的MVCC方案和加锁方案均不能有效解决幻读现象。")]),t._v(" "),a("p",[t._v("对于插入记录时，按照主键顺序，判断插入位置的下一条记录中是否有Gap锁，如果有，则加入失败。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230528180250152.png",alt:"image-20230528180250152"}})]),t._v(" "),a("p",[t._v("如果想在（20，正无穷）范围加Gap锁，那么，就在最后记录所在页的伪记录中加Gap锁")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230528180444764.png",alt:"image-20230528180444764"}})]),t._v(" "),a("h3",{attrs:{id:"next-key-locks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#next-key-locks"}},[t._v("#")]),t._v(" Next-Key Locks：")]),t._v(" "),a("p",[t._v("普通的锁，和Gap锁结合体")]),t._v(" "),a("h3",{attrs:{id:"插入意向锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插入意向锁"}},[t._v("#")]),t._v(" 插入意向锁：")]),t._v(" "),a("p",[t._v("他想规定事务在等待时候也在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://lzh-images.oss-cn-hangzhou.aliyuncs.com/images/image-20230528182049611.png",alt:"image-20230528182049611"}})]),t._v(" "),a("h3",{attrs:{id:"隐式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#隐式锁"}},[t._v("#")]),t._v(" 隐式锁")]),t._v(" "),a("p",[t._v("一般情况插入记录过程中不会加锁，所以插入记录过程，其它的事务可能想获取该记录写锁或读锁，会出现脏读或者脏写，那该怎么办？")]),t._v(" "),a("p",[t._v("根据事务id，如果有事务想对某条记录加锁，先判断该记录上的trx_id，如果该trx_id代表的事务在活跃状态，那么就帮它创建一个锁结构，is_waiting是false，然后再给自己创建锁结构，is_waiting是true。")])])}),[],!1,null,null,null);a.default=v.exports}}]);